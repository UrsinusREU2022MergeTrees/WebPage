<html>
    <body>
        <h1>Computable Metrics Between Chiral Merge Trees</h1>
        <p>
            We start with a fairly innocuous question: How do we train a computer to recognize that a group of real-valued, <b>sampled</b> functions is the same, <b>up to a parameterization?</b>  By <b>sampled</b>, we mean that we've evaluated the function at a sequence of numbers in its domain.  For instance, below are 100 samples of the function <b>cos(2 &pi; t)</b> over the interval <b>[0, 4]</b>
            
        </p>
        <img src = "Sampling.svg" width=700>
        <p> 
            By <b>parameterization</b>, we mean that the function can be pre-composed with a monotonically increasing function <b>h(x)</b> as <b>f(h(x))</b>.  For instance, the animation below shows 400 samples of different parameterizations of the function 
        </p>

        <div style="width:100px;">
            <h3>
                \[ f(x) = sin(2 \pi x) + x\]
            </h3>
        </div>
        <p>
            on the interval <b>[0, 1]</b>, composed with different monotonic functions <b>h(x)</b>
        </p>


        <img src = "Parameterization.gif">

        <p>
            Now stare at this picture of a bunch of sampled functions for a moment, and see if you can sort them into different groups, or "clusters"
        </p>

        <div style="padding: 100px;">
            <img src = "TrendingExamplesMixed.svg" width=900>
        </div>


        <p>
            There are actually 4 distinct clusters, as shown below
        </p>

        <div style="padding: 100px;">
            <img src = "TrendingExamples.svg" width=900>
        </div>

        <p>
            But how can we train a computer to discover that when all we're given is 400 numbers?
        </p>

        <HR>
        <h2>Approach #1: Dynamic Time Warping</h2>
        <p>
            One popular numerical approach to compare functions is known as dynamic time warping.  It works to explicitly uncover the optimal parameterization to best align two functions 
        </p>

        <p>
            Animation goes here
        </p>

        Hiroaki Sakoe and Seibi Chiba. Dynamic programming algorithm optimization for spoken word recog-
nition. IEEE transactions on acoustics, speech, and signal processing, 26(1):43â€“49, 1978



        <HR>
            <h2>Approach #2: Persistence Diagrams</h2>

            <p>
                Animation of approach
            </p>

            <div style="padding: 100px;">
                <img src = "PersistenceDiagrams.gif" width=900>
            </div>

            <p>
                Adding noise does not significantly change highly persistent points.
            </p>

            <div style="padding: 100px;">
                <img src = "NoisyPersistenceDiagrams.gif" width=900>
            </div>

            <p>

            </p>

        <HR>
            <h2>Approach #3: Merge Trees</h2>

            <p>
                Nick's video goes here
            </p>

            <p>
                Let's return to the original example.  We can reduce the problem of matching two functions up to a parameterization to matching two objects known as <b>chiral merge trees</b>.  
            </p>


            <img src = "TrendingExamples_Trees.svg" width=800>


            <p>
                These trees are more powerful than persistence diagrams.  Unlike persistence diagrams, they can tell apart time series which have been reflected.  They can also tell apart more subtle distances that persistence diagrams are blind to.  Below is an example of two functions that are clearly different, but which have the same persistence diagram.  On the other hand, their merge trees (superimposed on top of the functions) are distinct.
            </p>

            <img src = "MergeTreeSnippets.svg" width=900>

        <HR>
            <h2>The Holy Grail: Stable, Computable, And Informative Metric</h2>

            <ol>
                <li>Metric</li>
                <li>Stable</li>
                <li>Informative (lower bounded by the bottleneck between persistence diagrams)</li>
                <li>Computable (there exists a polynomial time algorithm to compute it)</li>
            </ol>

            <p>
                Put table here of existing approaches
            </p>

            <table>
                
            </table>


    </body>

    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</html>